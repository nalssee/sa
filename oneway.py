"""
Work on monthly average returns.

This program works based on conventional column names.
So you must be cautious when you name columns.
I've learned that it is a plausible scheme for computer programs.

*** columns that must be contained in a sequence(of rows) to
*** build portfolios
ret: monthly percentage return in concern
size: prc * shrout (be warned, not log size)
yyyymm: date column

rf: risk free
mkt_rf: market excess return
smb: smb
hml: hml

*** columns build_portfolios produce in a result table
ret1, ret2, ...: monthly average returns(equal- or value-) for each portfolio
    these columns are generated by 'build_portfolios'.
col1, co2, ...: other average values(equal- only) for each portfolio
    col could be 'size', 'bm', or whatever
nobs: number of observations for a given month
yyyymm: date column

"""
from pydwork.sqlplus import *
from pydwork.util import nchunks
from scipy.stats import ttest_rel
import statsmodels.api as sm
# from helpers import *
#
import statistics as st


# equally weighted average monthly return.
def eqweighted(rs):
    return st.mean(r.ret for r in rs)


def valweighted(rs):
   total_sum = sum(abs(r.size) for r in rs)
   return sum((r.ret * abs(r.size)) / total_sum for r in rs)


# weightfn: takes only one parm, 'rs'
def build_portfolios(seq, cols, nport, weight='eq',
                     factors=['mkt_rf', 'smb', 'hml']):
    """
    seq: sequence of rows
    cols: columns of interest, the first column is used to make portfolios
    nport: number of portfolios
    weight: if it is other than 'eq' then it is valued weighted
    factors: You can just add these up to cols if you want
             (although It may be a bit uglier because
             you will have the same 'nport' column for each factor),
             but I think it is not so bad an idea to put this aside explicitly.
    """
    col = cols[0]

    # Dont' make a fuss, your computer is good enough for handling
    # monthly data in memory
    # and sort a list just for sure can be forgiven.
    results = []
    for rs in Rows(seq).order(['yyyymm', col]).group('yyyymm'):
        r0 = rs[0]
        r = Row()
        nobs = len(rs)

        avgfn = eqweighted if weight == 'eq' else valweighted

        # Only when there are enough observations
        if nobs < nport:
            print('Not enough obs for', r0.yyyymm)
        else:
            r.nobs = nobs
            r.yyyymm = r0.yyyymm

            for k, rs1 in enumerate(nchunks(rs, nport), 1):
                setattr(r, 'ret' + str(k), avgfn(rs1))
                for c1 in cols[1:]:
                    avgval = st.mean([getattr(r, c1) for r in rs1])
                    setattr(r, c1 + str(k), avgval)

            # rf is a must, no matter what you do
            r.rf = r0.rf
            for fac in factors:
                setattr(r, fac, getattr(r0, fac))

            results.append(r)

    return Rows(results)


def star(val, pval):
    "put stars according to p-value"
    if pval < 0.001:
        return str(round(val, 2)) + '***'
    elif pval < 0.01:
        return str(round(val, 2)) + '**'
    elif pval < 0.05:
        return str(round(val, 2)) + '*'
    else:
        return str(round(val, 2))


def print_avg(ptable, col, nport,
              label='',
              print_header=True,
              print_tvalue=False,
              print_total=False,
              print_high_low=False):
    """if you want to label it other than the column name, pass a label
    """
    if print_header:
        header = [''] + [str(i) for i in range(1, nport + 1)] + \
                 (['H-L'] if print_high_low else []) + \
                 (['All'] if print_total else [])
        print(','.join(header))

    print(label or col, end=',')

    # just compute t values no matter what, it makes life easier
    list_of_vals = []
    tvalues = []
    for k in range(1, nport + 1):
        vals = ptable.col(col + str(k))
        list_of_vals.append(vals)
        tvalues.append(ttest_rel(vals, [0] * len(vals)))
        print(round(st.mean(vals), 2), end=',')

    if print_total:
        avgvals = [st.mean(xs) for xs in zip(*list_of_vals)]
        tvalues.append(ttest_rel(avgvals, [0] * len(avgvals)))
        print(round(st.mean(avgvals), 2), end=',')


    if print_high_low:
        high = list_of_vals[-1]
        low = list_of_vals[0]
        hl_tval = ttest_rel(high, low)
        tvalues.append(hl_tval)
        print(star(st.mean(high) - st.mean(low), hl_tval[1]), end=',')
    print()

    if print_tvalue:
        print('t-stat', end=',')
        for tval in tvalues:
            print(round(tval[0], 2), end=',')
        print()


# print regression results for time series
def print_reg_tseries(ptable, cols, nport,
                      print_tvalue=False,
                      print_header=True,
                      print_intercept_only=False,
                      intercept_label=''
                     ):

    if print_header:
        header = [''] + [str(i) for i in range(1, nport + 1)] + ['H-L']
        print(','.join(header))


    rf = ptable.col('rf')
    x = sm.add_constant(ptable.cols(cols))

    params = []
    tvalues = []
    pvalues = []
    for k in range(1, nport + 1):
        rs_rf = [a - b for a, b in zip(ptable.col('ret' + str(k)), rf)]
        results = sm.OLS(rs_rf, x).fit()
        params.append(results.params)
        tvalues.append(results.tvalues)
        pvalues.append(results.pvalues)

    rs_high = ptable.col('ret' + str(nport))
    rs_low = ptable.col('ret1')
    rs_hl = [a - b for a, b in zip(rs_high, rs_low)]

    results = sm.OLS(rs_hl, x).fit()
    params.append(results.params)
    tvalues.append(results.tvalues)
    pvalues.append(results.pvalues)

    if print_intercept_only:
        to_print_cols = [intercept_label]
    else:
        to_print_cols = [intercept_label] + cols

    for i, col in enumerate(to_print_cols):
        print(col, end=',')
        for param, pvalue in zip(params, pvalues):
            print(star(param[i], pvalue[i]), end=',')
        if print_tvalue:
            print()
            print('', end=',')
            for tval in tvalues:
                print('[' + str(round(tval[i], 2)) + ']', end=',')
        print()



